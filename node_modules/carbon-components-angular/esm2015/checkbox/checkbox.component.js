/**
 *
 * carbon-angular v0.0.0 | checkbox.component.js
 *
 * Copyright 2014, 2021 IBM
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0

 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */


import { ChangeDetectionStrategy, ChangeDetectorRef, Component, ElementRef, EventEmitter, Input, Output, ViewChild, HostBinding, HostListener } from "@angular/core";
import { NG_VALUE_ACCESSOR } from "@angular/forms";
/**
 * Defines the set of states for a checkbox component.
 */
export var CheckboxState;
(function (CheckboxState) {
    CheckboxState[CheckboxState["Init"] = 0] = "Init";
    CheckboxState[CheckboxState["Indeterminate"] = 1] = "Indeterminate";
    CheckboxState[CheckboxState["Checked"] = 2] = "Checked";
    CheckboxState[CheckboxState["Unchecked"] = 3] = "Unchecked";
})(CheckboxState || (CheckboxState = {}));
/**
 * Used to emit changes performed on checkbox components.
 *
 * @deprecated since v4
 */
export class CheckboxChange {
}
/**
 * [See demo](../../?path=/story/checkbox--basic)
 *
 * <example-url>../../iframe.html?id=checkbox--basic</example-url>
 */
export class Checkbox {
    /**
     * Creates an instance of `Checkbox`.
     */
    constructor(changeDetectorRef) {
        this.changeDetectorRef = changeDetectorRef;
        /**
         * Size of the checkbox.
         *
         * @deprecated since v4
         */
        this.size = "md";
        /**
         * Set to `true` for checkbox to be rendered without any classes on the host element.
         */
        this.inline = false;
        /**
         * Set to `true` for a disabled checkbox.
         */
        this.disabled = false;
        /**
         * Set to `true` for a loading checkbox.
         */
        this.skeleton = false;
        /**
         * Set to `true` to hide the checkbox labels.
         */
        this.hideLabel = false;
        /**
         * The unique id for the checkbox component.
         */
        this.id = `checkbox-${Checkbox.checkboxCount}`;
        // TODO: drop the `_`
        // tslint:disable-next-line:no-input-rename
        this._ariaLabel = "";
        /**
         * Emits click event.
         */
        this.click = new EventEmitter();
        /**
         * Emits event notifying other classes when a change in state occurs on a checkbox after a
         * click.
         *
         * @deprecated since v4 use `checked` and `checkedChange` instead
         */
        this.change = new EventEmitter();
        /**
         * Emits an event when the value of the checkbox changes.
         *
         * Allows double biding with the `checked` Input.
         */
        this.checkedChange = new EventEmitter();
        /**
         * Emits event notifying other classes when a change in state occurs specifically
         * on an indeterminate checkbox.
         */
        this.indeterminateChange = new EventEmitter();
        /**
         * Set to `true` if the input checkbox is selected (or checked).
         */
        this._checked = false;
        /**
         * Set to `true` if the input checkbox is in state indeterminate.
         */
        this._indeterminate = false;
        /**
         * Keeps a reference to the checkboxes current state, as defined in `CheckboxState`.
         */
        this.currentCheckboxState = CheckboxState.Init;
        /**
         * Called when checkbox is blurred. Needed to properly implement `ControlValueAccessor`.
         */
        this.onTouched = () => { };
        /**
         * Method set in `registerOnChange` to propagate changes back to the form.
         */
        this.propagateChange = (_) => { };
        Checkbox.checkboxCount++;
    }
    /**
     * Used to set the `aria-label` attribute on the input element.
     *
     * @deprecated since v4 use the `ariaLabel` input instead
     */
    // tslint:disable-next-line:no-input-rename
    set ariaLabel(value) {
        this._ariaLabel = value;
    }
    get ariaLabel() {
        return this._ariaLabel;
    }
    /**
     * Used to set the `aria-labelledby` attribute on the input element.
     *
     * @deprecated since v4 use the `ariaLabelledby` input instead
     */
    // tslint:disable-next-line:no-input-rename
    set ariaLabelledby(value) {
        this._ariaLabelledby = value;
    }
    get ariaLabelledby() {
        return this._ariaLabelledby;
    }
    /**
     * Set the checkbox's indeterminate state to match the parameter and transition the view to reflect the change.
     *
     * Allows double binding with the `indeterminateChange` Output.
     */
    set indeterminate(indeterminate) {
        if (indeterminate === this._indeterminate) {
            return;
        }
        // Set indeterminate and reset checked if indeterminate is true - only one of them can be true
        this._indeterminate = indeterminate;
        if (indeterminate && this._checked) {
            this._checked = false;
        }
        if (this._indeterminate) {
            this.transitionCheckboxState(CheckboxState.Indeterminate);
        }
        else {
            this.transitionCheckboxState(this.checked ? CheckboxState.Checked : CheckboxState.Unchecked);
        }
        this.changeDetectorRef.markForCheck();
        this.indeterminateChange.emit(this._indeterminate);
    }
    /**
     * Reflects whether the checkbox state is indeterminate.
     */
    get indeterminate() {
        return this._indeterminate;
    }
    /**
     * Sets the `checked` state. `true` for checked, `false` for unchecked
     *
     * Allows double binding with the `checkedChange` Output.
     */
    set checked(checked) {
        // Set checked and reset indeterminate if checked is true - only one of them can be true
        this.setChecked(checked, checked);
    }
    /**
     * Returns value `true` if state is selected for the checkbox.
     */
    get checked() {
        return this._checked;
    }
    get checkboxWrapperClass() {
        return !this.inline;
    }
    get formItemClass() {
        return !this.inline;
    }
    /**
     * Toggle the selected state of the checkbox.
     */
    toggle() {
        // Flip checked and reset indeterminate
        this.setChecked(!this.checked, true);
    }
    /**
     * Writes a value from `ngModel` to the component.
     *
     * In this case the value is the `checked` property.
     *
     * @param value boolean, corresponds to the `checked` property.
     */
    writeValue(value) {
        // Set checked and reset indeterminate
        this.setChecked(!!value, true);
    }
    /**
     * Sets a method in order to propagate changes back to the form.
     */
    registerOnChange(fn) {
        this.propagateChange = fn;
    }
    /**
     * Registers a callback to be triggered when the control has been touched.
     * @param fn Callback to be triggered when the checkbox is touched.
     */
    registerOnTouched(fn) {
        this.onTouched = fn;
    }
    focusOut() {
        this.onTouched();
    }
    /**
     * Executes on the event of a change within `Checkbox` to block propagation.
     */
    onChange(event) {
        event.stopPropagation();
    }
    /**
     * Handles click events on the `Checkbox` and emits changes to other classes.
     */
    onClick(event) {
        if (this.click.observers.length) {
            // Disable default checkbox activation behavior which flips checked and resets indeterminate.
            // This allows the parent component to control the checked/indeterminate properties.
            event.preventDefault();
            this.click.emit();
            return;
        }
        if (!this.disabled) {
            this.toggle();
            this.transitionCheckboxState(this._checked ? CheckboxState.Checked : CheckboxState.Unchecked);
            this.emitChangeEvent();
        }
    }
    /**
     * Handles changes between checkbox states.
     */
    transitionCheckboxState(newState) {
        this.currentCheckboxState = newState;
    }
    /**
     * Creates instance of `CheckboxChange` used to propagate the change event.
     */
    emitChangeEvent() {
        /* begin deprecation */
        let event = new CheckboxChange();
        event.source = this;
        event.checked = this.checked;
        this.change.emit(event);
        /* end deprecation */
        this.checkedChange.emit(this.checked);
        this.propagateChange(this.checked);
    }
    /**
     * Updates the checkbox if it is in the indeterminate state.
     */
    ngAfterViewInit() {
        if (this.indeterminate) {
            this.inputCheckbox.nativeElement.indeterminate = true;
            this.checked = false;
        }
    }
    /**
     * Sets checked state and optionally resets indeterminate state.
     */
    setChecked(checked, resetIndeterminate) {
        if (checked === this._checked) {
            return;
        }
        this._checked = checked;
        // Reset indeterminate if requested
        if (resetIndeterminate && this._indeterminate) {
            this._indeterminate = false;
            Promise.resolve().then(() => {
                this.indeterminateChange.emit(this._indeterminate);
            });
        }
        this.changeDetectorRef.markForCheck();
    }
}
/**
 * Variable used for creating unique ids for checkbox components.
 */
Checkbox.checkboxCount = 0;
Checkbox.decorators = [
    { type: Component, args: [{
                selector: "ibm-checkbox",
                template: `
		<div class="bx--form-item bx--checkbox-wrapper">
			<input
				#inputCheckbox
				class="bx--checkbox"
				type="checkbox"
				[id]="id + '_input'"
				[value]="value"
				[name]="name"
				[required]="required"
				[checked]="checked"
				[disabled]="disabled"
				[indeterminate]="indeterminate"
				[attr.aria-labelledby]="ariaLabelledby"
				[attr.aria-checked]="(indeterminate ? 'mixed' : checked)"
				(change)="onChange($event)"
				(click)="onClick($event)">
			<label
				[for]="id + '_input'"
				[attr.aria-label]="ariaLabel"
				class="bx--checkbox-label"
				[ngClass]="{
					'bx--skeleton' : skeleton
				}">
				<span [ngClass]="{'bx--visually-hidden' : hideLabel}" class="bx--checkbox-label-text">
					<ng-content></ng-content>
				</span>
			</label>
		</div>
	`,
                providers: [
                    {
                        provide: NG_VALUE_ACCESSOR,
                        useExisting: Checkbox,
                        multi: true
                    }
                ],
                changeDetection: ChangeDetectionStrategy.OnPush
            }] }
];
/** @nocollapse */
Checkbox.ctorParameters = () => [
    { type: ChangeDetectorRef }
];
Checkbox.propDecorators = {
    size: [{ type: Input }],
    nested: [{ type: Input }],
    inline: [{ type: Input }],
    disabled: [{ type: Input }],
    skeleton: [{ type: Input }],
    hideLabel: [{ type: Input }],
    name: [{ type: Input }],
    id: [{ type: Input }],
    required: [{ type: Input }],
    value: [{ type: Input }],
    ariaLabel: [{ type: Input, args: ["aria-label",] }],
    _ariaLabel: [{ type: Input, args: ["ariaLabel",] }],
    ariaLabelledby: [{ type: Input, args: ["aria-labelledby",] }],
    _ariaLabelledby: [{ type: Input, args: ["ariaLabelledby",] }],
    indeterminate: [{ type: Input }],
    checked: [{ type: Input }],
    checkboxWrapperClass: [{ type: HostBinding, args: ["class.bx--checkbox-wrapper",] }],
    formItemClass: [{ type: HostBinding, args: ["class.bx--form-item",] }],
    click: [{ type: Output }],
    change: [{ type: Output }],
    checkedChange: [{ type: Output }],
    indeterminateChange: [{ type: Output }],
    inputCheckbox: [{ type: ViewChild, args: ["inputCheckbox", { static: false },] }],
    focusOut: [{ type: HostListener, args: ["focusout",] }]
};
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiY2hlY2tib3guY29tcG9uZW50LmpzIiwic291cmNlUm9vdCI6Im5nOi8vY2FyYm9uLWNvbXBvbmVudHMtYW5ndWxhci9jaGVja2JveC8iLCJzb3VyY2VzIjpbImNoZWNrYm94LmNvbXBvbmVudC50cyJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiQUFBQSxPQUFPLEVBRU4sdUJBQXVCLEVBQ3ZCLGlCQUFpQixFQUNqQixTQUFTLEVBQ1QsVUFBVSxFQUNWLFlBQVksRUFDWixLQUFLLEVBQ0wsTUFBTSxFQUNOLFNBQVMsRUFDVCxXQUFXLEVBQ1gsWUFBWSxFQUNaLE1BQU0sZUFBZSxDQUFDO0FBQ3ZCLE9BQU8sRUFBRSxpQkFBaUIsRUFBd0IsTUFBTSxnQkFBZ0IsQ0FBQztBQUd6RTs7R0FFRztBQUNILE1BQU0sQ0FBTixJQUFZLGFBS1g7QUFMRCxXQUFZLGFBQWE7SUFDeEIsaURBQUksQ0FBQTtJQUNKLG1FQUFhLENBQUE7SUFDYix1REFBTyxDQUFBO0lBQ1AsMkRBQVMsQ0FBQTtBQUNWLENBQUMsRUFMVyxhQUFhLEtBQWIsYUFBYSxRQUt4QjtBQUVEOzs7O0dBSUc7QUFDSCxNQUFNLE9BQU8sY0FBYztDQVMxQjtBQUVEOzs7O0dBSUc7QUEwQ0gsTUFBTSxPQUFPLFFBQVE7SUEwTHBCOztPQUVHO0lBQ0gsWUFBc0IsaUJBQW9DO1FBQXBDLHNCQUFpQixHQUFqQixpQkFBaUIsQ0FBbUI7UUF2TDFEOzs7O1dBSUc7UUFDTSxTQUFJLEdBQWdCLElBQUksQ0FBQztRQU9sQzs7V0FFRztRQUNNLFdBQU0sR0FBRyxLQUFLLENBQUM7UUFDeEI7O1dBRUc7UUFDTSxhQUFRLEdBQUcsS0FBSyxDQUFDO1FBQzFCOztXQUVHO1FBQ00sYUFBUSxHQUFHLEtBQUssQ0FBQztRQUMxQjs7V0FFRztRQUNNLGNBQVMsR0FBRyxLQUFLLENBQUM7UUFLM0I7O1dBRUc7UUFDTSxPQUFFLEdBQUcsWUFBWSxRQUFRLENBQUMsYUFBYSxFQUFFLENBQUM7UUF1Qm5ELHFCQUFxQjtRQUNyQiwyQ0FB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Q0FBQyxjQUFjLENBQUMsQ0FBQztZQUNwRCxDQUFDLENBQUMsQ0FBQztTQUNIO1FBQ0QsSUFBSSxDQUFDLGlCQUFpQixDQUFDLFlBQVksRUFBRSxDQUFDO0lBQ3ZDLENBQUM7O0FBNVREOztHQUVHO0FBQ0ksc0JBQWEsR0FBRyxDQUFDLENBQUM7O1lBN0N6QixTQUFTLFNBQUM7Z0JBQ1YsUUFBUSxFQUFFLGNBQWM7Z0JBQ3hCLFFBQVEsRUFBRTs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7RUE2QlQ7Z0JBQ0QsU0FBUyxFQUFFO29CQUNWO3dCQUNDLE9BQU8sRUFBRSxpQkFBaUI7d0JBQzFCLFdBQVcsRUFBRSxRQUFRO3dCQUNyQixLQUFLLEVBQUUsSUFBSTtxQkFDWDtpQkFDRDtnQkFDRCxlQUFlLEVBQUUsdUJBQXVCLENBQUMsTUFBTTthQUMvQzs7OztZQXBGQSxpQkFBaUI7OzttQkFnR2hCLEtBQUs7cUJBTUwsS0FBSztxQkFJTCxLQUFLO3VCQUlMLEtBQUs7dUJBSUwsS0FBSzt3QkFJTCxLQUFLO21CQUlMLEtBQUs7aUJBSUwsS0FBSzt1QkFJTCxLQUFLO29CQUlMLEtBQUs7d0JBT0wsS0FBSyxTQUFDLFlBQVk7eUJBVWxCLEtBQUssU0FBQyxXQUFXOzZCQVFqQixLQUFLLFNBQUMsaUJBQWlCOzhCQVV2QixLQUFLLFNBQUMsZ0JBQWdCOzRCQU90QixLQUFLO3NCQStCTCxLQUFLO21DQVlMLFdBQVcsU0FBQyw0QkFBNEI7NEJBR3hDLFdBQVcsU0FBQyxxQkFBcUI7b0JBT2pDLE1BQU07cUJBT04sTUFBTTs0QkFPTixNQUFNO2tDQU1OLE1BQU07NEJBb0JOLFNBQVMsU0FBQyxlQUFlLEVBQUUsRUFBRSxNQUFNLEVBQUUsS0FBSyxFQUFFO3VCQTRDNUMsWUFBWSxTQUFDLFVBQVUiLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQge1xuXHRBZnRlclZpZXdJbml0LFxuXHRDaGFuZ2VEZXRlY3Rpb25TdHJhdGVneSxcblx0Q2hhbmdlRGV0ZWN0b3JSZWYsXG5cdENvbXBvbmVudCxcblx0RWxlbWVudFJlZixcblx0RXZlbnRFbWl0dGVyLFxuXHRJbnB1dCxcblx0T3V0cHV0LFxuXHRWaWV3Q2hpbGQsXG5cdEhvc3RCaW5kaW5nLFxuXHRIb3N0TGlzdGVuZXJcbn0gZnJvbSBcIkBhbmd1bGFyL2NvcmVcIjtcbmltcG9ydCB7IE5HX1ZBTFVFX0FDQ0VTU09SLCBDb250cm9sVmFsdWVBY2Nlc3NvciB9IGZyb20gXCJAYW5ndWxhci9mb3Jtc1wiO1xuaW1wb3J0IHsgQ2hlY2tib3hWYWx1ZSB9IGZyb20gXCIuL2NoZWNrYm94LnR5cGVzXCI7XG5cbi8qKlxuICogRGVmaW5lcyB0aGUgc2V0IG9mIHN0YXRlcyBmb3IgYSBjaGVja2JveCBjb21wb25lbnQuXG4gKi9cbmV4cG9ydCBlbnVtIENoZWNrYm94U3RhdGUge1xuXHRJbml0LFxuXHRJbmRldGVybWluYXRlLFxuXHRDaGVja2VkLFxuXHRVbmNoZWNrZWRcbn1cblxuLyoqXG4gKiBVc2VkIHRvIGVtaXQgY2hhbmdlcyBwZXJmb3JtZWQgb24gY2hlY2tib3ggY29tcG9uZW50cy5cbiAqXG4gKiBAZGVwcmVjYXRlZCBzaW5jZSB2NFxuICovXG5leHBvcnQgY2xhc3MgQ2hlY2tib3hDaGFuZ2Uge1xuXHQvKipcblx0ICogQ29udGFpbnMgdGhlIGBDaGVja2JveGAgdGhhdCBoYXMgYmVlbiBjaGFuZ2VkLlxuXHQgKi9cblx0c291cmNlOiBDaGVja2JveDtcblx0LyoqXG5cdCAqIFRoZSBzdGF0ZSBvZiB0aGUgYENoZWNrYm94YCBlbmNvbXBhc3NlZCBpbiB0aGUgYENoZWNrYm94Q2hhbmdlYCBjbGFzcy5cblx0ICovXG5cdGNoZWNrZWQ6IGJvb2xlYW47XG59XG5cbi8qKlxuICogW1NlZSBkZW1vXSguLi8uLi8/cGF0aD0vc3RvcnkvY2hlY2tib3gtLWJhc2ljKVxuICpcbiAqIDxleGFtcGxlLXVybD4uLi8uLi9pZnJhbWUuaHRtbD9pZD1jaGVja2JveC0tYmFzaWM8L2V4YW1wbGUtdXJsPlxuICovXG5AQ29tcG9uZW50KHtcblx0c2VsZWN0b3I6IFwiaWJtLWNoZWNrYm94XCIsXG5cdHRlbXBsYXRlOiBgXG5cdFx0PGRpdiBjbGFzcz1cImJ4LS1mb3JtLWl0ZW0gYngtLWNoZWNrYm94LXdyYXBwZXJcIj5cblx0XHRcdDxpbnB1dFxuXHRcdFx0XHQjaW5wdXRDaGVja2JveFxuXHRcdFx0XHRjbGFzcz1cImJ4LS1jaGVja2JveFwiXG5cdFx0XHRcdHR5cGU9XCJjaGVja2JveFwiXG5cdFx0XHRcdFtpZF09XCJpZCArICdfaW5wdXQnXCJcblx0XHRcdFx0W3ZhbHVlXT1cInZhbHVlXCJcblx0XHRcdFx0W25hbWVdPVwibmFtZVwiXG5cdFx0XHRcdFtyZXF1aXJlZF09XCJyZXF1aXJlZFwiXG5cdFx0XHRcdFtjaGVja2VkXT1cImNoZWNrZWRcIlxuXHRcdFx0XHRbZGlzYWJsZWRdPVwiZGlzYWJsZWRcIlxuXHRcdFx0XHRbaW5kZXRlcm1pbmF0ZV09XCJpbmRldGVybWluYXRlXCJcblx0XHRcdFx0W2F0dHIuYXJpYS1sYWJlbGxlZGJ5XT1cImFyaWFMYWJlbGxlZGJ5XCJcblx0XHRcdFx0W2F0dHIuYXJpYS1jaGVja2VkXT1cIihpbmRldGVybWluYXRlID8gJ21peGVkJyA6IGNoZWNrZWQpXCJcblx0XHRcdFx0KGNoYW5nZSk9XCJvbkNoYW5nZSgkZXZlbnQpXCJcblx0XHRcdFx0KGNsaWNrKT1cIm9uQ2xpY2soJGV2ZW50KVwiPlxuXHRcdFx0PGxhYmVsXG5cdFx0XHRcdFtmb3JdPVwiaWQgKyAnX2lucHV0J1wiXG5cdFx0XHRcdFthdHRyLmFyaWEtbGFiZWxdPVwiYXJpYUxhYmVsXCJcblx0XHRcdFx0Y2xhc3M9XCJieC0tY2hlY2tib3gtbGFiZWxcIlxuXHRcdFx0XHRbbmdDbGFzc109XCJ7XG5cdFx0XHRcdFx0J2J4LS1za2VsZXRvbicgOiBza2VsZXRvblxuXHRcdFx0XHR9XCI+XG5cdFx0XHRcdDxzcGFuIFtuZ0NsYXNzXT1cInsnYngtLXZpc3VhbGx5LWhpZGRlbicgOiBoaWRlTGFiZWx9XCIgY2xhc3M9XCJieC0tY2hlY2tib3gtbGFiZWwtdGV4dFwiPlxuXHRcdFx0XHRcdDxuZy1jb250ZW50PjwvbmctY29udGVudD5cblx0XHRcdFx0PC9zcGFuPlxuXHRcdFx0PC9sYWJlbD5cblx0XHQ8L2Rpdj5cblx0YCxcblx0cHJvdmlkZXJzOiBbXG5cdFx0e1xuXHRcdFx0cHJvdmlkZTogTkdfVkFMVUVfQUNDRVNTT1IsXG5cdFx0XHR1c2VFeGlzdGluZzogQ2hlY2tib3gsXG5cdFx0XHRtdWx0aTogdHJ1ZVxuXHRcdH1cblx0XSxcblx0Y2hhbmdlRGV0ZWN0aW9uOiBDaGFuZ2VEZXRlY3Rpb25TdHJhdGVneS5PblB1c2hcbn0pXG5leHBvcnQgY2xhc3MgQ2hlY2tib3ggaW1wbGVtZW50cyBDb250cm9sVmFsdWVBY2Nlc3NvciwgQWZ0ZXJWaWV3SW5pdCB7XG5cdC8qKlxuXHQgKiBWYXJpYWJsZSB1c2VkIGZvciBjcmVhdGluZyB1bmlxdWUgaWRzIGZvciBjaGVja2JveCBjb21wb25lbnRzLlxuXHQgKi9cblx0c3RhdGljIGNoZWNrYm94Q291bnQgPSAwO1xuXG5cdC8qKlxuXHQgKiBTaXplIG9mIHRoZSBjaGVja2JveC5cblx0ICpcblx0ICogQGRlcHJlY2F0ZWQgc2luY2UgdjRcblx0ICovXG5cdEBJbnB1dCgpIHNpemU6IFwic21cIiB8IFwibWRcIiA9IFwibWRcIjtcblx0LyoqXG5cdCAqIFNldCB0byBgdHJ1ZWAgZm9yIGNoZWNrYm94IHRvIGJlIHJlbmRlcmVkIHdpdGggbmVzdGVkIHN0eWxlcy5cblx0ICpcblx0ICogQGRlcHJlY2F0ZWQgc2luY2UgdjRcblx0ICovXG5cdEBJbnB1dCgpIG5lc3RlZDogYm9vbGVhbjtcblx0LyoqXG5cdCAqIFNldCB0byBgdHJ1ZWAgZm9yIGNoZWNrYm94IHRvIGJlIHJlbmRlcmVkIHdpdGhvdXQgYW55IGNsYXNzZXMgb24gdGhlIGhvc3QgZWxlbWVudC5cblx0ICovXG5cdEBJbnB1dCgpIGlubGluZSA9IGZhbHNlO1xuXHQvKipcblx0ICogU2V0IHRvIGB0cnVlYCBmb3IgYSBkaXNhYmxlZCBjaGVja2JveC5cblx0ICovXG5cdEBJbnB1dCgpIGRpc2FibGVkID0gZmFsc2U7XG5cdC8qKlxuXHQgKiBTZXQgdG8gYHRydWVgIGZvciBhIGxvYWRpbmcgY2hlY2tib3guXG5cdCAqL1xuXHRASW5wdXQoKSBza2VsZXRvbiA9IGZhbHNlO1xuXHQvKipcblx0ICogU2V0IHRvIGB0cnVlYCB0byBoaWRlIHRoZSBjaGVja2JveCBsYWJlbHMuXG5cdCAqL1xuXHRASW5wdXQoKSBoaWRlTGFiZWwgPSBmYWxzZTtcblx0LyoqXG5cdCAqIFNldHMgdGhlIG5hbWUgYXR0cmlidXRlIG9uIHRoZSBgaW5wdXRgIGVsZW1lbnQuXG5cdCAqL1xuXHRASW5wdXQoKSBuYW1lOiBzdHJpbmc7XG5cdC8qKlxuXHQgKiBUaGUgdW5pcXVlIGlkIGZvciB0aGUgY2hlY2tib3ggY29tcG9uZW50LlxuXHQgKi9cblx0QElucHV0KCkgaWQgPSBgY2hlY2tib3gtJHtDaGVja2JveC5jaGVja2JveENvdW50fWA7XG5cdC8qKlxuXHQgKiBSZWZsZWN0cyB0aGUgcmVxdWlyZWQgYXR0cmlidXRlIG9mIHRoZSBgaW5wdXRgIGVsZW1lbnQuXG5cdCAqL1xuXHRASW5wdXQoKSByZXF1aXJlZDogYm9vbGVhbjtcblx0LyoqXG5cdCAqIFNldHMgdGhlIHZhbHVlIGF0dHJpYnV0ZSBvbiB0aGUgYGlucHV0YCBlbGVtZW50LlxuXHQgKi9cblx0QElucHV0KCkgdmFsdWU6IENoZWNrYm94VmFsdWU7XG5cdC8qKlxuXHQgKiBVc2VkIHRvIHNldCB0aGUgYGFyaWEtbGFiZWxgIGF0dHJpYnV0ZSBvbiB0aGUgaW5wdXQgZWxlbWVudC5cblx0ICpcblx0ICogQGRlcHJlY2F0ZWQgc2luY2UgdjQgdXNlIHRoZSBgYXJpYUxhYmVsYCBpbnB1dCBpbnN0ZWFkXG5cdCAqL1xuXHQvLyB0c2xpbnQ6ZGlzYWJsZS1uZXh0LWxpbmU6bm8taW5wdXQtcmVuYW1lXG5cdEBJbnB1dChcImFyaWEtbGFiZWxcIikgc2V0IGFyaWFMYWJlbCh2YWx1ZTogc3RyaW5nKSB7XG5cdFx0dGhpcy5fYXJpYUxhYmVsID0gdmFsdWU7XG5cdH1cblxuXHRnZXQgYXJpYUxhYmVsKCkge1xuXHRcdHJldHVybiB0aGlzLl9hcmlhTGFiZWw7XG5cdH1cblxuXHQvLyBUT0RPOiBkcm9wIHRoZSBgX2Bcblx0Ly8gdHNsaW50OmRpc2FibGUtbmV4dC1saW5lOm5vLWlucHV0LXJlbmFtZVxuXHRASW5wdXQoXCJhcmlhTGFiZWxcIikgX2FyaWFMYWJlbCA9IFwiXCI7XG5cblx0LyoqXG5cdCAqIFVzZWQgdG8gc2V0IHRoZSBgYXJpYS1sYWJlbGxlZGJ5YCBhdHRyaWJ1dGUgb24gdGhlIGlucHV0IGVsZW1lbnQuXG5cdCAqXG5cdCAqIEBkZXByZWNhdGVkIHNpbmNlIHY0IHVzZSB0aGUgYGFyaWFMYWJlbGxlZGJ5YCBpbnB1dCBpbnN0ZWFkXG5cdCAqL1xuXHQvLyB0c2xpbnQ6ZGlzYWJsZS1uZXh0LWxpbmU6bm8taW5wdXQtcmVuYW1lXG5cdEBJbnB1dChcImFyaWEtbGFiZWxsZWRieVwiKSBzZXQgYXJpYUxhYmVsbGVkYnkodmFsdWU6IHN0cmluZykge1xuXHRcdHRoaXMuX2FyaWFMYWJlbGxlZGJ5ID0gdmFsdWU7XG5cdH1cblxuXHRnZXQgYXJpYUxhYmVsbGVkYnkoKSB7XG5cdFx0cmV0dXJuIHRoaXMuX2FyaWFMYWJlbGxlZGJ5O1xuXHR9XG5cblx0Ly8gVE9ETzogZHJvcCB0aGUgYF9gXG5cdC8vIHRzbGludDpkaXNhYmxlLW5leHQtbGluZTpuby1pbnB1dC1yZW5hbWVcblx0QElucHV0KFwiYXJpYUxhYmVsbGVkYnlcIikgX2FyaWFMYWJlbGxlZGJ5OiBzdHJpbmc7XG5cblx0LyoqXG5cdCAqIFNldCB0aGUgY2hlY2tib3gncyBpbmRldGVybWluYXRlIHN0YXRlIHRvIG1hdGNoIHRoZSBwYXJhbWV0ZXIgYW5kIHRyYW5zaXRpb24gdGhlIHZpZXcgdG8gcmVmbGVjdCB0aGUgY2hhbmdlLlxuXHQgKlxuXHQgKiBBbGxvd3MgZG91YmxlIGJpbmRpbmcgd2l0aCB0aGUgYGluZGV0ZXJtaW5hdGVDaGFuZ2VgIE91dHB1dC5cblx0ICovXG5cdEBJbnB1dCgpIHNldCBpbmRldGVybWluYXRlKGluZGV0ZXJtaW5hdGU6IGJvb2xlYW4pIHtcblx0XHRpZiAoaW5kZXRlcm1pbmF0ZSA9PT0gdGhpcy5faW5kZXRlcm1pbmF0ZSkge1xuXHRcdFx0cmV0dXJuO1xuXHRcdH1cblx0XHQvLyBTZXQgaW5kZXRlcm1pbmF0ZSBhbmQgcmVzZXQgY2hlY2tlZCBpZiBpbmRldGVybWluYXRlIGlzIHRydWUgLSBvbmx5IG9uZSBvZiB0aGVtIGNhbiBiZSB0cnVlXG5cdFx0dGhpcy5faW5kZXRlcm1pbmF0ZSA9IGluZGV0ZXJtaW5hdGU7XG5cdFx0aWYgKGluZGV0ZXJtaW5hdGUgJiYgdGhpcy5fY2hlY2tlZCkge1xuXHRcdFx0dGhpcy5fY2hlY2tlZCA9IGZhbHNlO1xuXHRcdH1cblxuXHRcdGlmICh0aGlzLl9pbmRldGVybWluYXRlKSB7XG5cdFx0XHR0aGlzLnRyYW5zaXRpb25DaGVja2JveFN0YXRlKENoZWNrYm94U3RhdGUuSW5kZXRlcm1pbmF0ZSk7XG5cdFx0fSBlbHNlIHtcblx0XHRcdHRoaXMudHJhbnNpdGlvbkNoZWNrYm94U3RhdGUodGhpcy5jaGVja2VkID8gQ2hlY2tib3hTdGF0ZS5DaGVja2VkIDogQ2hlY2tib3hTdGF0ZS5VbmNoZWNrZWQpO1xuXHRcdH1cblx0XHR0aGlzLmNoYW5nZURldGVjdG9yUmVmLm1hcmtGb3JDaGVjaygpO1xuXHRcdHRoaXMuaW5kZXRlcm1pbmF0ZUNoYW5nZS5lbWl0KHRoaXMuX2luZGV0ZXJtaW5hdGUpO1xuXHR9XG5cblx0LyoqXG5cdCAqIFJlZmxlY3RzIHdoZXRoZXIgdGhlIGNoZWNrYm94IHN0YXRlIGlzIGluZGV0ZXJtaW5hdGUuXG5cdCAqL1xuXHRnZXQgaW5kZXRlcm1pbmF0ZSgpIHtcblx0XHRyZXR1cm4gdGhpcy5faW5kZXRlcm1pbmF0ZTtcblx0fVxuXG5cdC8qKlxuXHQgKiBTZXRzIHRoZSBgY2hlY2tlZGAgc3RhdGUuIGB0cnVlYCBmb3IgY2hlY2tlZCwgYGZhbHNlYCBmb3IgdW5jaGVja2VkXG5cdCAqXG5cdCAqIEFsbG93cyBkb3VibGUgYmluZGluZyB3aXRoIHRoZSBgY2hlY2tlZENoYW5nZWAgT3V0cHV0LlxuXHQgKi9cblx0QElucHV0KCkgc2V0IGNoZWNrZWQgKGNoZWNrZWQ6IGJvb2xlYW4pIHtcblx0XHQvLyBTZXQgY2hlY2tlZCBhbmQgcmVzZXQgaW5kZXRlcm1pbmF0ZSBpZiBjaGVja2VkIGlzIHRydWUgLSBvbmx5IG9uZSBvZiB0aGVtIGNhbiBiZSB0cnVlXG5cdFx0dGhpcy5zZXRDaGVja2VkKGNoZWNrZWQsIGNoZWNrZWQpO1xuXHR9XG5cblx0LyoqXG5cdCAqIFJldHVybnMgdmFsdWUgYHRydWVgIGlmIHN0YXRlIGlzIHNlbGVjdGVkIGZvciB0aGUgY2hlY2tib3guXG5cdCAqL1xuXHRnZXQgY2hlY2tlZCgpIHtcblx0XHRyZXR1cm4gdGhpcy5fY2hlY2tlZDtcblx0fVxuXG5cdEBIb3N0QmluZGluZyhcImNsYXNzLmJ4LS1jaGVja2JveC13cmFwcGVyXCIpIGdldCBjaGVja2JveFdyYXBwZXJDbGFzcygpIHtcblx0XHRyZXR1cm4gIXRoaXMuaW5saW5lO1xuXHR9XG5cdEBIb3N0QmluZGluZyhcImNsYXNzLmJ4LS1mb3JtLWl0ZW1cIikgZ2V0IGZvcm1JdGVtQ2xhc3MoKSB7XG5cdFx0cmV0dXJuICF0aGlzLmlubGluZTtcblx0fVxuXG5cdC8qKlxuXHQgKiBFbWl0cyBjbGljayBldmVudC5cblx0ICovXG5cdEBPdXRwdXQoKSBjbGljayA9IG5ldyBFdmVudEVtaXR0ZXI8dm9pZD4oKTtcblx0LyoqXG5cdCAqIEVtaXRzIGV2ZW50IG5vdGlmeWluZyBvdGhlciBjbGFzc2VzIHdoZW4gYSBjaGFuZ2UgaW4gc3RhdGUgb2NjdXJzIG9uIGEgY2hlY2tib3ggYWZ0ZXIgYVxuXHQgKiBjbGljay5cblx0ICpcblx0ICogQGRlcHJlY2F0ZWQgc2luY2UgdjQgdXNlIGBjaGVja2VkYCBhbmQgYGNoZWNrZWRDaGFuZ2VgIGluc3RlYWRcblx0ICovXG5cdEBPdXRwdXQoKSBjaGFuZ2UgPSBuZXcgRXZlbnRFbWl0dGVyPGFueT4oKTtcblxuXHQvKipcblx0ICogRW1pdHMgYW4gZXZlbnQgd2hlbiB0aGUgdmFsdWUgb2YgdGhlIGNoZWNrYm94IGNoYW5nZXMuXG5cdCAqXG5cdCAqIEFsbG93cyBkb3VibGUgYmlkaW5nIHdpdGggdGhlIGBjaGVja2VkYCBJbnB1dC5cblx0ICovXG5cdEBPdXRwdXQoKSBjaGVja2VkQ2hhbmdlID0gbmV3IEV2ZW50RW1pdHRlcjxib29sZWFuPigpO1xuXG5cdC8qKlxuXHQgKiBFbWl0cyBldmVudCBub3RpZnlpbmcgb3RoZXIgY2xhc3NlcyB3aGVuIGEgY2hhbmdlIGluIHN0YXRlIG9jY3VycyBzcGVjaWZpY2FsbHlcblx0ICogb24gYW4gaW5kZXRlcm1pbmF0ZSBjaGVja2JveC5cblx0ICovXG5cdEBPdXRwdXQoKSBpbmRldGVybWluYXRlQ2hhbmdlID0gbmV3IEV2ZW50RW1pdHRlcjxib29sZWFuPigpO1xuXG5cdC8qKlxuXHQgKiBTZXQgdG8gYHRydWVgIGlmIHRoZSBpbnB1dCBjaGVja2JveCBpcyBzZWxlY3RlZCAob3IgY2hlY2tlZCkuXG5cdCAqL1xuXHRfY2hlY2tlZCA9IGZhbHNlO1xuXHQvKipcblx0ICogU2V0IHRvIGB0cnVlYCBpZiB0aGUgaW5wdXQgY2hlY2tib3ggaXMgaW4gc3RhdGUgaW5kZXRlcm1pbmF0ZS5cblx0ICovXG5cdF9pbmRldGVybWluYXRlID0gZmFsc2U7XG5cblx0LyoqXG5cdCAqIEtlZXBzIGEgcmVmZXJlbmNlIHRvIHRoZSBjaGVja2JveGVzIGN1cnJlbnQgc3RhdGUsIGFzIGRlZmluZWQgaW4gYENoZWNrYm94U3RhdGVgLlxuXHQgKi9cblx0Y3VycmVudENoZWNrYm94U3RhdGUgPSBDaGVja2JveFN0YXRlLkluaXQ7XG5cblx0LyoqXG5cdCAqIE1haW50YWlucyBhIHJlZmVyZW5jZSB0byB0aGUgdmlldyBET00gZWxlbWVudCBvZiB0aGUgYENoZWNrYm94YC5cblx0ICovXG5cdC8vIEB0cy1pZ25vcmVcblx0QFZpZXdDaGlsZChcImlucHV0Q2hlY2tib3hcIiwgeyBzdGF0aWM6IGZhbHNlIH0pIGlucHV0Q2hlY2tib3g6IEVsZW1lbnRSZWY7XG5cblx0LyoqXG5cdCAqIENyZWF0ZXMgYW4gaW5zdGFuY2Ugb2YgYENoZWNrYm94YC5cblx0ICovXG5cdGNvbnN0cnVjdG9yKHByb3RlY3RlZCBjaGFuZ2VEZXRlY3RvclJlZjogQ2hhbmdlRGV0ZWN0b3JSZWYpIHtcblx0XHRDaGVja2JveC5jaGVja2JveENvdW50Kys7XG5cdH1cblxuXHQvKipcblx0ICogVG9nZ2xlIHRoZSBzZWxlY3RlZCBzdGF0ZSBvZiB0aGUgY2hlY2tib3guXG5cdCAqL1xuXHRwdWJsaWMgdG9nZ2xlKCkge1xuXHRcdC8vIEZsaXAgY2hlY2tlZCBhbmQgcmVzZXQgaW5kZXRlcm1pbmF0ZVxuXHRcdHRoaXMuc2V0Q2hlY2tlZCghdGhpcy5jaGVja2VkLCB0cnVlKTtcblx0fVxuXG5cdC8qKlxuXHQgKiBXcml0ZXMgYSB2YWx1ZSBmcm9tIGBuZ01vZGVsYCB0byB0aGUgY29tcG9uZW50LlxuXHQgKlxuXHQgKiBJbiB0aGlzIGNhc2UgdGhlIHZhbHVlIGlzIHRoZSBgY2hlY2tlZGAgcHJvcGVydHkuXG5cdCAqXG5cdCAqIEBwYXJhbSB2YWx1ZSBib29sZWFuLCBjb3JyZXNwb25kcyB0byB0aGUgYGNoZWNrZWRgIHByb3BlcnR5LlxuXHQgKi9cblx0cHVibGljIHdyaXRlVmFsdWUodmFsdWU6IGFueSkge1xuXHRcdC8vIFNldCBjaGVja2VkIGFuZCByZXNldCBpbmRldGVybWluYXRlXG5cdFx0dGhpcy5zZXRDaGVja2VkKCEhdmFsdWUsIHRydWUpO1xuXHR9XG5cblx0LyoqXG5cdCAqIFNldHMgYSBtZXRob2QgaW4gb3JkZXIgdG8gcHJvcGFnYXRlIGNoYW5nZXMgYmFjayB0byB0aGUgZm9ybS5cblx0ICovXG5cdHB1YmxpYyByZWdpc3Rlck9uQ2hhbmdlKGZuOiBhbnkpIHtcblx0XHR0aGlzLnByb3BhZ2F0ZUNoYW5nZSA9IGZuO1xuXHR9XG5cblx0LyoqXG5cdCAqIFJlZ2lzdGVycyBhIGNhbGxiYWNrIHRvIGJlIHRyaWdnZXJlZCB3aGVuIHRoZSBjb250cm9sIGhhcyBiZWVuIHRvdWNoZWQuXG5cdCAqIEBwYXJhbSBmbiBDYWxsYmFjayB0byBiZSB0cmlnZ2VyZWQgd2hlbiB0aGUgY2hlY2tib3ggaXMgdG91Y2hlZC5cblx0ICovXG5cdHB1YmxpYyByZWdpc3Rlck9uVG91Y2hlZChmbjogYW55KSB7XG5cdFx0dGhpcy5vblRvdWNoZWQgPSBmbjtcblx0fVxuXG5cdEBIb3N0TGlzdGVuZXIoXCJmb2N1c291dFwiKVxuXHRmb2N1c091dCgpIHtcblx0XHR0aGlzLm9uVG91Y2hlZCgpO1xuXHR9XG5cblx0LyoqXG5cdCAqIEV4ZWN1dGVzIG9uIHRoZSBldmVudCBvZiBhIGNoYW5nZSB3aXRoaW4gYENoZWNrYm94YCB0byBibG9jayBwcm9wYWdhdGlvbi5cblx0ICovXG5cdG9uQ2hhbmdlKGV2ZW50OiBFdmVudCkge1xuXHRcdGV2ZW50LnN0b3BQcm9wYWdhdGlvbigpO1xuXHR9XG5cblx0LyoqXG5cdCAqIEhhbmRsZXMgY2xpY2sgZXZlbnRzIG9uIHRoZSBgQ2hlY2tib3hgIGFuZCBlbWl0cyBjaGFuZ2VzIHRvIG90aGVyIGNsYXNzZXMuXG5cdCAqL1xuXHRvbkNsaWNrKGV2ZW50OiBFdmVudCkge1xuXHRcdGlmICh0aGlzLmNsaWNrLm9ic2VydmVycy5sZW5ndGgpIHtcblx0XHRcdC8vIERpc2FibGUgZGVmYXVsdCBjaGVja2JveCBhY3RpdmF0aW9uIGJlaGF2aW9yIHdoaWNoIGZsaXBzIGNoZWNrZWQgYW5kIHJlc2V0cyBpbmRldGVybWluYXRlLlxuXHRcdFx0Ly8gVGhpcyBhbGxvd3MgdGhlIHBhcmVudCBjb21wb25lbnQgdG8gY29udHJvbCB0aGUgY2hlY2tlZC9pbmRldGVybWluYXRlIHByb3BlcnRpZXMuXG5cdFx0XHRldmVudC5wcmV2ZW50RGVmYXVsdCgpO1xuXHRcdFx0dGhpcy5jbGljay5lbWl0KCk7XG5cdFx0XHRyZXR1cm47XG5cdFx0fVxuXHRcdGlmICghdGhpcy5kaXNhYmxlZCkge1xuXHRcdFx0dGhpcy50b2dnbGUoKTtcblx0XHRcdHRoaXMudHJhbnNpdGlvbkNoZWNrYm94U3RhdGUodGhpcy5fY2hlY2tlZCA/IENoZWNrYm94U3RhdGUuQ2hlY2tlZCA6IENoZWNrYm94U3RhdGUuVW5jaGVja2VkKTtcblx0XHRcdHRoaXMuZW1pdENoYW5nZUV2ZW50KCk7XG5cdFx0fVxuXHR9XG5cblxuXHQvKipcblx0ICogQ2FsbGVkIHdoZW4gY2hlY2tib3ggaXMgYmx1cnJlZC4gTmVlZGVkIHRvIHByb3Blcmx5IGltcGxlbWVudCBgQ29udHJvbFZhbHVlQWNjZXNzb3JgLlxuXHQgKi9cblx0b25Ub3VjaGVkOiAoKSA9PiBhbnkgPSAoKSA9PiB7fTtcblxuXHQvKipcblx0ICogSGFuZGxlcyBjaGFuZ2VzIGJldHdlZW4gY2hlY2tib3ggc3RhdGVzLlxuXHQgKi9cblx0dHJhbnNpdGlvbkNoZWNrYm94U3RhdGUobmV3U3RhdGU6IENoZWNrYm94U3RhdGUpIHtcblx0XHR0aGlzLmN1cnJlbnRDaGVja2JveFN0YXRlID0gbmV3U3RhdGU7XG5cdH1cblxuXHQvKipcblx0ICogQ3JlYXRlcyBpbnN0YW5jZSBvZiBgQ2hlY2tib3hDaGFuZ2VgIHVzZWQgdG8gcHJvcGFnYXRlIHRoZSBjaGFuZ2UgZXZlbnQuXG5cdCAqL1xuXHRlbWl0Q2hhbmdlRXZlbnQoKSB7XG5cdFx0LyogYmVnaW4gZGVwcmVjYXRpb24gKi9cblx0XHRsZXQgZXZlbnQgPSBuZXcgQ2hlY2tib3hDaGFuZ2UoKTtcblx0XHRldmVudC5zb3VyY2UgPSB0aGlzO1xuXHRcdGV2ZW50LmNoZWNrZWQgPSB0aGlzLmNoZWNrZWQ7XG5cdFx0dGhpcy5jaGFuZ2UuZW1pdChldmVudCk7XG5cdFx0LyogZW5kIGRlcHJlY2F0aW9uICovXG5cblx0XHR0aGlzLmNoZWNrZWRDaGFuZ2UuZW1pdCh0aGlzLmNoZWNrZWQpO1xuXHRcdHRoaXMucHJvcGFnYXRlQ2hhbmdlKHRoaXMuY2hlY2tlZCk7XG5cdH1cblxuXHQvKipcblx0ICogVXBkYXRlcyB0aGUgY2hlY2tib3ggaWYgaXQgaXMgaW4gdGhlIGluZGV0ZXJtaW5hdGUgc3RhdGUuXG5cdCAqL1xuXHRuZ0FmdGVyVmlld0luaXQoKSB7XG5cdFx0aWYgKHRoaXMuaW5kZXRlcm1pbmF0ZSkge1xuXHRcdFx0dGhpcy5pbnB1dENoZWNrYm94Lm5hdGl2ZUVsZW1lbnQuaW5kZXRlcm1pbmF0ZSA9IHRydWU7XG5cdFx0XHR0aGlzLmNoZWNrZWQgPSBmYWxzZTtcblx0XHR9XG5cdH1cblxuXHQvKipcblx0ICogTWV0aG9kIHNldCBpbiBgcmVnaXN0ZXJPbkNoYW5nZWAgdG8gcHJvcGFnYXRlIGNoYW5nZXMgYmFjayB0byB0aGUgZm9ybS5cblx0ICovXG5cdHByb3BhZ2F0ZUNoYW5nZSA9IChfOiBhbnkpID0+IHt9O1xuXG5cdC8qKlxuXHQgKiBTZXRzIGNoZWNrZWQgc3RhdGUgYW5kIG9wdGlvbmFsbHkgcmVzZXRzIGluZGV0ZXJtaW5hdGUgc3RhdGUuXG5cdCAqL1xuXHRwcml2YXRlIHNldENoZWNrZWQoY2hlY2tlZDogYm9vbGVhbiwgcmVzZXRJbmRldGVybWluYXRlOiBib29sZWFuKSB7XG5cdFx0aWYgKGNoZWNrZWQgPT09IHRoaXMuX2NoZWNrZWQpIHtcblx0XHRcdHJldHVybjtcblx0XHR9XG5cdFx0dGhpcy5fY2hlY2tlZCA9IGNoZWNrZWQ7XG5cdFx0Ly8gUmVzZXQgaW5kZXRlcm1pbmF0ZSBpZiByZXF1ZXN0ZWRcblx0XHRpZiAocmVzZXRJbmRldGVybWluYXRlICYmIHRoaXMuX2luZGV0ZXJtaW5hdGUpIHtcblx0XHRcdHRoaXMuX2luZGV0ZXJtaW5hdGUgPSBmYWxzZTtcblx0XHRcdFByb21pc2UucmVzb2x2ZSgpLnRoZW4oKCkgPT4ge1xuXHRcdFx0XHR0aGlzLmluZGV0ZXJtaW5hdGVDaGFuZ2UuZW1pdCh0aGlzLl9pbmRldGVybWluYXRlKTtcblx0XHRcdH0pO1xuXHRcdH1cblx0XHR0aGlzLmNoYW5nZURldGVjdG9yUmVmLm1hcmtGb3JDaGVjaygpO1xuXHR9XG59XG4iXX0=